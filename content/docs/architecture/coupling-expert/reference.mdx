---
title: Reference
description: Documentation détaillée sur les dépendances circulaires, le couplage, la cohésion et les stratégies de résolution.
---

# Coupling Expert - Documentation de Référence

Documentation détaillée sur les dépendances circulaires, le couplage, la cohésion et les stratégies de résolution.

---

## Table des Matières

1. [Dépendances Circulaires](#1-dépendances-circulaires)
2. [Couplage](#2-couplage)
3. [Cohésion](#3-cohésion)
4. [Barrel Files et Imports](#4-barrel-files-et-imports)
5. [Outils d'Analyse](#5-outils-danalyse)
6. [Patterns de Résolution](#6-patterns-de-résolution)

---

## 1. Dépendances Circulaires

### Définition

Une dépendance circulaire (ou cyclique) existe lorsque deux ou plusieurs modules dépendent directement ou indirectement l'un de l'autre pour fonctionner.

### Types de Cycles

#### Cycle Direct (A ↔ B)

Le cas le plus simple : A importe B et B importe A.

```
user.service.ts → auth.service.ts
auth.service.ts → user.service.ts
```

#### Cycle Indirect (A → B → C → A)

Plus difficile à détecter : le cycle passe par plusieurs modules.

```
order.service.ts → payment.service.ts
payment.service.ts → notification.service.ts
notification.service.ts → order.service.ts
```

#### Cycle via Barrel (A → index → B → index)

Les fichiers index.ts créent des cycles cachés en réexportant tout.

```
components/Button.tsx → components/index.ts
components/index.ts → components/Modal.tsx
components/Modal.tsx → components/index.ts (pour Button)
```

### Symptômes

| Symptôme | Description |
|----------|-------------|
| `undefined` inattendu | Variable non initialisée au moment de l'accès |
| `Cannot access X before initialization` | Erreur TDZ en ESM |
| Comportement aléatoire | Dépend de l'ordre de chargement |
| HMR cassé | Vite/Webpack ne peut pas résoudre le graphe |
| Build échoué | Bundler ne peut pas déterminer l'ordre |
| Tests instables | Résultats différents selon l'ordre d'exécution |

### Pourquoi JavaScript Tolère (Parfois)

JavaScript/Node.js peut gérer certains cycles grâce au cache de modules :

1. Premier import de A → commence l'exécution de A
2. A importe B → exécute B
3. B importe A → retourne le module A partiellement chargé (cache)
4. B termine → A continue

Cela fonctionne si B n'utilise pas immédiatement les exports de A. Mais c'est fragile et imprévisible.

### Impact sur les Outils

| Outil | Comportement |
|-------|-------------|
| TypeScript | Warning possible, pas toujours détecté |
| Webpack | Peut échouer ou produire des bundles incorrects |
| Vite | HMR ne fonctionne plus, erreurs cryptiques |
| Jest | Tests instables, ordre d'exécution problématique |
| ESLint | Détection avec `import/no-cycle` (coûteux) |

---

## 2. Couplage

### Définition

Le couplage mesure le degré d'interdépendance entre les modules. Un couplage faible est souhaitable pour la maintenabilité.

### Types de Couplage (du plus fort au plus faible)

| Type | Description | Exemple |
|------|-------------|---------|
| **Content** | Module accède aux internes d'un autre | Accès direct aux propriétés privées |
| **Common** | Modules partagent des données globales | Variables globales partagées |
| **Control** | Module contrôle le flux d'un autre | Passer un flag qui change le comportement |
| **Stamp** | Module reçoit une structure dont il n'utilise qu'une partie | Passer un objet User pour n'utiliser que l'ID |
| **Data** | Module reçoit seulement les données nécessaires | Passer uniquement l'ID |
| **Message** | Communication via événements/messages | Event bus, pub/sub |

### Métriques de Couplage

#### CBO (Coupling Between Objects)

Nombre de classes auxquelles une classe est couplée (utilise ou est utilisée par).

- **Seuil recommandé** : < 8-15
- **Interprétation** : CBO élevé = difficile à modifier sans impact

#### Efferent Coupling (Ce)

Nombre de classes dont dépend une classe (classes utilisées).

- Ce élevé = classe dépendante, difficile à isoler
- Risque : changements en cascade

#### Afferent Coupling (Ca)

Nombre de classes qui dépendent d'une classe (classes utilisatrices).

- Ca élevé = classe centrale, difficile à modifier
- Bénéfice : indique une abstraction réutilisable

#### Instabilité (I)

Formule : `I = Ce / (Ca + Ce)`

- I proche de 0 : stable (beaucoup de dépendants)
- I proche de 1 : instable (dépend de beaucoup)

#### RFC (Response For a Class)

Nombre de méthodes pouvant être exécutées en réponse à un message.

- Inclut méthodes de la classe + méthodes appelées
- RFC élevé = complexité de test accrue

### Visualisation du Couplage

#### Dependency Structure Matrix (DSM)

Matrice où les lignes/colonnes sont les modules, les cellules indiquent les dépendances.

```
       A  B  C  D
    A  -  X  X  -
    B  -  -  X  -
    C  -  -  -  X
    D  X  -  -  -   ← Cycle détecté (D → A)
```

Avantage : Visualise les cycles comme des dépendances "au-dessus de la diagonale".

---

## 3. Cohésion

### Définition

La cohésion mesure à quel point les éléments d'un module sont liés et travaillent ensemble vers un objectif commun. Une cohésion forte est souhaitable.

### Types de Cohésion (de la plus faible à la plus forte)

| Type | Description | Qualité |
|------|-------------|---------|
| **Coincidentelle** | Éléments sans relation | ❌ Très mauvais |
| **Logique** | Éléments liés par catégorie | ❌ Mauvais |
| **Temporelle** | Exécutés au même moment | ⚠️ Faible |
| **Procédurale** | Suivent une séquence | ⚠️ Acceptable |
| **Communicationnelle** | Opèrent sur mêmes données | ✅ Bonne |
| **Séquentielle** | Output de l'un = input du suivant | ✅ Bonne |
| **Fonctionnelle** | Contribuent à une seule fonction | ✅ Excellente |

### Métriques de Cohésion

#### LCOM (Lack of Cohesion of Methods)

Mesure le "manque" de cohésion. Plus le LCOM est bas, meilleure est la cohésion.

**LCOM1** : Nombre de paires de méthodes sans attributs communs

**LCOM4** : Basé sur le graphe de connectivité des méthodes
- LCOM4 = 1 : Parfaitement cohésif
- LCOM4 > 1 : Classe potentiellement à diviser

#### CAM (Cohesion Among Methods)

Intersection des types de paramètres entre méthodes.
- CAM élevé = bonne cohésion

### Signes de Faible Cohésion

| Signe | Indication |
|-------|------------|
| Classe > 500 lignes | Trop de responsabilités |
| Nom avec "Manager", "Utility" | Fourre-tout |
| Méthodes n'utilisant pas les mêmes attributs | LCOM élevé |
| Difficile à nommer simplement | Responsabilités multiples |
| Tests nécessitant beaucoup de setup | Trop de dépendances |

---

## 4. Barrel Files et Imports

### Qu'est-ce qu'un Barrel File ?

Un fichier (généralement `index.ts`) qui réexporte d'autres modules sans contenir de code propre.

```typescript
// components/index.ts (barrel)
export * from './Button';
export * from './Modal';
export * from './Input';
```

### Problèmes des Barrel Files

#### 1. Performance de Chargement

Importer depuis un barrel charge TOUS les modules réexportés :

```typescript
// Charge Button, Modal, Input, même si on veut juste Button
import { Button } from './components';
```

**Impact réel** : Un projet NextJS a réduit les modules chargés de 11k à 3.5k (68%) en supprimant les barrels.

#### 2. Création de Cycles

Les barrels créent des cycles cachés :

```
Button.tsx imports Modal from './index'
index.ts imports Button, Modal
Modal.tsx imports Button from './index'
= Cycle via index.ts
```

#### 3. Tree-Shaking Inefficace

Les bundlers peuvent ne pas éliminer le code non utilisé à cause des barrels.

#### 4. Linting Lent

`import/no-cycle` devient extrêmement lent avec des barrels car le graphe explose.

### Quand les Barrels Sont Appropriés

| Contexte | Recommandation |
|----------|----------------|
| Librairie publique (npm) | ✅ Nécessaire pour le point d'entrée |
| API publique d'un package interne | ✅ Définit l'interface stable |
| Code applicatif interne | ❌ Éviter, imports directs |
| Monorepo inter-packages | ✅ Un barrel par package |

### Alternative aux Barrels

**Imports directs :**

```typescript
// Au lieu de
import { Button, Modal } from './components';

// Préférer
import { Button } from './components/Button';
import { Modal } from './components/Modal';
```

**Auto-imports IDE :**

Les IDE modernes gèrent les imports automatiquement, rendant les barrels moins utiles.

### Outils Anti-Barrel

- `eslint-plugin-barrel-files` : Lint contre les barrels
- Oxlint / Biome : Règles intégrées
- Import path aliases : Simplifier sans barrels

---

## 5. Outils d'Analyse

### Détection de Cycles

#### dpdm

```bash
# Installation
npm install -g dpdm

# Analyse
dpdm ./src/main.ts

# Options utiles
dpdm --no-warning --no-tree --circular ./src/main.ts
```

**Avantages** :
- Très précis (utilise le parser TypeScript)
- Supporte TS/JS mixtes
- Plus fiable que madge pour les projets complexes

#### madge

```bash
# Installation
npm install -g madge

# Détection de cycles
madge --circular --extensions ts,tsx src/

# Génération de graphe
madge --image graph.svg src/

# Avec configuration
madge --ts-config ./tsconfig.json --circular src/
```

**Avantages** :
- Visualisation graphique
- Intégration facile en CI
- Supporte CSS preprocessors

**Limites** :
- Peut ignorer certains fichiers .ts
- Ne détecte que les cycles directs

#### ESLint import/no-cycle

```json
{
  "rules": {
    "import/no-cycle": ["error", { "maxDepth": 3 }]
  }
}
```

**Conseil** : Exécuter seulement en pre-commit (très lent).

### Analyse de Couplage

#### SonarQube

- Métriques : CBO, LCOM, RFC, complexité
- Dashboard de suivi dans le temps
- Intégration CI/CD

#### Code Climate

- Analyse automatique sur PR
- Métriques de maintenabilité
- Détection de code dupliqué

### Visualisation

#### Dependency Cruiser

```bash
npx depcruise --output-type dot src | dot -T svg > graph.svg
```

Génère des graphes interactifs avec filtres.

#### NDepend (pour .NET) / JDepend (pour Java)

- Matrices de dépendances
- Détection de violations architecturales
- Métriques complètes

---

## 6. Patterns de Résolution

### Extraction de Module Commun

**Problème** : A dépend de B qui dépend de A

**Solution** : Identifier le code partagé et l'extraire dans C

```
Avant :
A ↔ B

Après :
A → C ← B
```

**Quand utiliser** :
- Les deux modules ont une dépendance commune
- Le code extrait est réutilisable

### Inversion de Dépendance

**Problème** : Module high-level dépend de low-level

**Solution** : Abstraire avec une interface

```
Avant :
OrderService → EmailSender (concret)

Après :
OrderService → INotifier (interface)
EmailSender implements INotifier
```

**Quand utiliser** :
- Couplage à une implémentation concrète
- Besoin de flexibilité (tests, changement d'implémentation)

### Injection de Dépendance

**Problème** : Création de dépendances en dur

**Solution** : Passer les dépendances en paramètre

```typescript
// Avant
class OrderService {
  private emailSender = new EmailSender();
}

// Après
class OrderService {
  constructor(private notifier: INotifier) {}
}
```

### Lazy Loading / Dynamic Import

**Problème** : Cycle via import statique

**Solution** : Charger dynamiquement quand nécessaire

```typescript
// Avant
import { CircularDep } from './circular';

// Après
const CircularDep = await import('./circular');
```

**Limites** :
- Code asynchrone plus complexe
- Peut masquer le problème plutôt que le résoudre

### Médiation (Event Bus)

**Problème** : Modules communiquent directement

**Solution** : Passer par un médiateur

```
Avant :
OrderService → NotificationService → OrderService

Après :
OrderService → EventBus ← NotificationService
```

**Quand utiliser** :
- Communication entre features découplées
- Pattern pub/sub approprié

### Réorganisation des Layers

**Problème** : Violations de layers architecturaux

**Solution** : Repositionner les modules dans le bon layer

```
Avant :
UI → Infrastructure → Domain → UI (cycle)

Après :
UI → Application → Domain
Infrastructure → Domain (inversé via interfaces)
```

---

## Ressources

### Articles de Référence
- [TkDodo - Please Stop Using Barrel Files](https://tkdodo.eu/blog/please-stop-using-barrel-files)
- [Michel Weststrate - Fix Circular Dependencies Once and For All](https://medium.com/visual-development/how-to-fix-nasty-circular-dependency-issues-once-and-for-all-in-javascript-typescript-a04c987cf0de)
- [Atlassian - 75% Faster Builds by Removing Barrel Files](https://www.atlassian.com/blog/atlassian-engineering/faster-builds-when-removing-barrel-files)
- [Marvin Hagemeister - The Barrel File Debacle](https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-7/)

### Outils
- [dpdm - GitHub](https://github.com/nicolo-ribaudo/dpdm)
- [madge - GitHub](https://github.com/pahen/madge)
- [Dependency Cruiser](https://github.com/sverweij/dependency-cruiser)
- [SonarQube](https://www.sonarqube.org/)

### Documentation
- [GeeksforGeeks - Coupling and Cohesion](https://www.geeksforgeeks.org/software-engineering/software-engineering-coupling-and-cohesion/)
- [TechTarget - Software Coupling Metrics](https://www.techtarget.com/searchapparchitecture/tip/The-basics-of-software-coupling-metrics-and-concepts)
